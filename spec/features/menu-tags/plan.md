# Implementation Plan

**Plan:** Реализовать админскую секцию «Теги» и связать её с блюдами, добавив CRUD-операции, хранение в Supabase и обновление UI редактора меню.

## Data sources / schemas

- Создать миграцию Supabase `tags` со структурой: `id uuid pk`, `name text not null`, `position integer default 0`, `created_at`, `updated_at`, check на непустое имя и уникальный индекс `lower(btrim(name))`.
- Расширить модель блюда (таблица `menu_items`/аналог) полем `tag_ids uuid[] default '{}'` с ограничением на уникальность внутри массива; обновить связанные схемы в `~/schemas` и тип `EditableMenuItem` (поле `tags` → массив идентификаторов и, при необходимости, отображаемых названий).
- Добавить seed/фикстуры при необходимости в тестовой среде (опционально).

## Contracts and interfaces

- REST API в `app/server/api/admin/tags`: `GET /` (список тегов), `POST /` (создание), `PATCH /:id` (обновление названия), `DELETE /:id` (удаление с проверкой связей). Ответы по схеме, аналогичной категориям, с сообщениями об ошибках.
- Сервисный слой `~/server/services/tags.ts` с функциями `fetchTags`, `createTag`, `updateTag`, `deleteTag`, использующий Supabase client и общие обработчики ошибок.
- Клиентский composable `useMenuTags` в `app/composables` по аналогии с `useMenuCategories`: хранение списка тегов, состояния загрузки/ошибок и методов CRUD.
- Интегрировать теги в редактор блюд: в `app/pages/admin/create.vue` обновить форму блюда (вероятно компонент `MenuItemEditor`) для мультивыбора тегов и передачи `tag_ids` в API сохранения меню.
- Обновить схемы в `~/schemas/tags` (новый файл) и расширить существующие `menu`/`menu-items` схемы для валидации тегов.

## Architecture / Components

- UI: создать компонент `MenuTagManager.vue` в `app/components/admin` с аналогичной структурой категорий, но с уникальными подписями и ограничениями (24 символа). Подключить компонент на странице `admin/create.vue` ниже блока категорий.
- Компонент выбора тегов в карточке блюда: использовать `Combobox`/`MultiSelect` (проверить наличие), иначе создать легкий UI на основе `Listbox` или чекбоксов. Состояние синхронизируется с массивом `selectedTagIds`.
- Обновить логику сохранения меню (`handleSubmit`) чтобы включать теги в payload; при удалении тега запускать очистку на сервере (в транзакции или отдельным update запросом).
- В Supabase сервисе при удалении тега выполнить `update menu_items set tag_ids = array_remove(tag_ids, :tagId)` перед удалением, чтобы сохранить целостность.
- Учесть SSR/Prefetch: в `useAsyncData` загрузить теги вместе с категориями, добавить обработку ошибок.

## Risks

- Несогласованность между типами и фактической схемой блюд, если поле `tags` сейчас строковое — потребуется миграция данных и обратная совместимость.
- Возможное отсутствие готового UI-компонента для мультивыбора может увеличить время реализации; стоит проверить переиспользование существующих ui-компонентов.
- Удаление тега, который уже используется, может затронуть много записей и вызвать задержку; стоит использовать батч-операции и отображать состояние загрузки.
- Ограничения на количество тегов и UX при большом списке (десятки) — может потребоваться пагинация или поиск.

## Assumptions

- Таблица с блюдами поддерживает миграции без даунтайма, и добавление массива UUID не нарушит существующие функции.
- API сохранения меню готов принимать дополнительные поля; если нет — придётся расширить соответствующие endpoint'ы.
- Клиентский код допускает использование `defineModel`/`v-model` для массивов без значительных переделок.
- Валидация на backend и frontend может использовать одну схему Zod; при её отсутствии будет добавлена новая.
